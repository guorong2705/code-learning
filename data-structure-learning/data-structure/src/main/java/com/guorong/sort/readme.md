## 排序算法的稳定性

- 稳定性是指同样大小的样本再排序之后不会改变相对次序。
- 对于基础类型来说，稳定性是毫无意义。
- 对于非基础类型来说，稳定性有重要的意义。
- 有些排序算法可以实现成稳定的，而有些排序算法无论如何都实现不成稳定的。

## 排序算法各维度比较

| 算法     | 时间复杂度 | 额外空间复杂度 | 稳定性 |
| -------- | ---------- | -------------- | ------ |
| 选择排序 | O(N^2)     | O(1)           | 无     |
| 冒泡排序 | O(N^2)     | O(1)           | 有     |
| 插入排序 | O(N^2)     | O(1)           | 有     |
| 归并排序 | O(N*logN)  | O(N)           | 有     |
| 快速排序 | O(N*logN)  | O(logN)        | 无     |
| 堆排序   | O(N*logN)  | O(1)           | 无     |
| 计数排序 | O(N)       | O(M)           | 有     |
| 基数排序 | O(N)       | O(N)           | 有     |

## 排序算法总结

* 不基于比较的排序，对样本数据有严格要求，不易改写。
* 基于比较的排序，只要规定好两个样本怎么比较大小，就可以直接复用。
* 基于比较的排序，时间复杂度的极限是 O(N*logN)。
* 时间复杂度O(N*logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的。
* 为了绝对的速度选快排，为了节省空间选择堆排序，为了稳定性选择归并排序。

## 排序算法常见的坑

1. 归并排序的额外空间复杂度可以变成O(1)，“归并排序 内部缓存法”，但是将变得不再稳定。
2. “原地归并排序” 是垃圾帖子，会让时间复杂度变成O(N^2)。
3. 快速排序稳定性改进，“01 stable sort”，但是会对样本数据要求更多。

## 快速排序

快速排序（QuickSort）的核心是**分区（Partition）**操作，它将数组划分为两部分，使得一部分元素小于或等于基准（pivot），另一部分元素大于或等于基准。不同的分区方法在实现逻辑、性能、适用场景等方面有所不同。

### 1. **Lomuto 分区**

Lomuto 分区是一种单向扫描的分区方法，逻辑简单，适合教学和小型数组。

**工作原理**

- 选择数组最后一个元素 arr[high] 作为基准。
- 使用两个指针：
  - i：标记小于等于基准区域的右边界，初始为 low - 1。
  - j：遍历数组，从 low 到 high - 1。
- 如果 arr[j] <= pivot，将 i 向后移动一位，并交换 arr[i] 和 arr[j]。
- 分区结束后，交换 arr[i + 1] 和 arr[high]，将基准放到正确位置。
- 返回 i + 1 作为基准位置。

**优缺点**

- 优点：
  - 实现简单，单向扫描逻辑直观，易于理解和调试。
  - 返回基准的最终位置，递归逻辑清晰。
- 缺点：
  - 交换次数较多（平均 n/2 次，n 为子数组长度）。
  - 对重复元素处理效率低，频繁移动等于基准的元素。
  - 最坏情况（如有序数组）分区不均匀，易退化为 O(n²)。

**适用场景**

- 教学和学习。
- 小型数组或对性能要求不高的场景。

### 2. **Hoare 分区**

Hoare 分区是一种双向扫描的分区方法，效率高，广泛用于实际应用。

**工作原理**

- 选择数组第一个元素 arr[low] 作为基准（也可选择其他元素）。
- 使用两个指针：
  - left：从 low  向右移动，寻找 >= pivot 的元素。
  - right：从 high 向左移动，寻找 <= pivot 的元素。
- 当 left < right 时，交换 arr[left] 和 arr[right]。
- 当 left >= right 时，分区结束，返回 right 作为分区边界。
- 基准位置不固定，由后续递归处理。

**优缺点**

- 优点：
  - 交换次数少（平均 n/3 次），性能比 Lomuto 分区快 2-3 倍。
  - 对重复元素处理高效，均匀分配到两侧。
  - 分区更均匀，减少最坏情况概率。
- 缺点：
  - 实现稍复杂，需处理双向指针和交叉逻辑。
  - 返回分区边界而非基准位置，理解稍难。
  - 需防止指针越界。

**适用场景**

- 大规模数据排序。
- 通用排序场景（随机、部分有序、重复元素）。
- 性能敏感场景（如标准库实现）。

















